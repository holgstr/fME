---
title: "Get started"
#date: "`r Sys.Date()`"
output: 
  rmarkdown::html_vignette:
    toc: true
    toc_depth: 3
params:
  EVAL: !r identical(Sys.getenv("NOT_CRAN"), "true")
vignette: >
  %\VignetteIndexEntry{Get started}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

## Introduction

The `fme` package computes, aggregates and visualizes forward marginal effects (FMEs) for any supervised machine learning model. For a more in-depth understanding, refer to the [paper][1]. The package has two main functions: `fme()` computes FMEs for a given model and data, and `came()` finds subspaces of the feature space where FMEs are more homogeneous.

### Installation

The latest version of `fme` can be installed directly from GitHub:

```{r, eval=FALSE}
library(devtools)
install_github("holgstr/fme")
library(fme)   
```

```{r, echo=FALSE, message=FALSE}
set.seed(123)
library(fme) 
```

### Example

For demonstration purposes, we will consider usage data from the Capital Bike Sharing scheme (Fanaee-T and Gama, 2014). It contains information about bike sharing usage in Washington, D.C. for the years 2011-2012 during the period from 7 to 8 a.m. We are interested in predicting `count` (the total number of bikes lent out to users).

```{r}
data(bikes)
head(bikes) 
```

FMEs are a model-agnostic interpretation method, i.e., they can be applied to any supervised regression and binary classification model. See [here][1] for a list of models currently supported by the `fme` package. Let's try it with a random forest using the `ranger` algorithm:

```{r, message=FALSE}
library(mlr3verse)
forest = lrn("regr.ranger")$train(as_task_regr(x = bikes, id = "bikes", target = "count"))
```

---

## Compute FMEs

The concept of the FME applies to both categorical and numerical features. They can be computed with the `fme()` function.

### Categorical Features

For a categorical feature, the FME of an observation is simply the difference in predictions when changing the observed category of the feature to the category specified in `step.size`. For instance, one could be interested in the effect of rainy weather on the bike sharing demand, i.e., the FME of changing the feature value of `weather` to `rain` for observations where weather is either `clear` or `misty`:

```{r}
effects = fme(model = forest,
              data = bikes,
              target = "count",
              feature = "weather",
              step.size = "rain")
```

Note that the FME is defined observation-wise, which means we have computed the FME for every observation in the data with non-rainy weather. We can use `summary()` to aggregate the FMEs to produce a global estimate of the effect:
```{r}
summary(effects)
```
As you can see, the average marginal effect (AME) of `rain` is -55. The AME is computed as a simple mean over all observation-wise FMEs. Therefore, while holding all other features constant, rainy weather can be expected to reduce bike sharing usage by 55. \
Also, we can extract all relevant aggregate information from the `effects` object:
```{r}
effects$ame
```
For a more in-depth analysis, you can inspect the FME for each observation in the data set:
```{r}
head(effects$results)
```
Or, even better, you can plot the empirical distribution of the FMEs:
```{r, warning=FALSE}
plot(effects)
```

### Numerical Features

FMEs for numerical features are defined for multivariate feature changes, i.e., `step.size` can be a vector. The `fme()` function accepts both univariate (e.g., `step.size = c(1)`) and bivariate (e.g., `step.size = c(1, 1)`) feature changes.

#### Univariate Feature Changes

One might be interested in the FME of an increase in temperature by 3 degrees Celsius (°C)
on bike sharing usage. Thus, we compute FMEs for the` feature = "temp"` and `step.size = 3`.

```{r}
effects2 = fme(model = forest,
               data = bikes,
               target = "count",
               feature = "temp",
               step.size = 3,
               ep.method = "envelope")
```

Note that we have specified `ep.method = "envelope"`. This means we exclude observations for which adding 3°C to the temperature results in the temperature value falling outside the range of `temp` in the overall data. Therefore, we reduce the risk of asking the model to extrapolate.

```{r, warning=FALSE}
plot(effects2, jitter = c(0.2, 0))
```

The black arrow indicates direction and magnitude of `step.size`. The horizontal line in the plot indicates that on average, the FME of a temperature increase of 3°C on bike sharing usage is roughly 9. As can be seen, the observation-wise effects seem to vary for different values of temp. While the FMEs tends to be positive for lower temperature values (0-17°C), they tend to be negative for higher temperature values (>17°C).

#### Bivariate Feature Changes

Bivariate feature changes can be considered when one is interested in the combined effect of two features on the target variable. Let's assume you want to estimate the effect of a decrease in temperature by 3°C combined with a decrease in humidity by 10 percentage points, i.e., the FME for `feature = c("temp", "humidity")` and `step.size = c(−3, −0.1)`:

```{r}
effects3 = fme(model = forest,
               data = bikes,
               target = "count",
               feature = c("temp", "humidity"),
               step.size = c(-3, -0.1),
               ep.method = "envelope")

plot(effects3, jitter = c(0.1, 0.02))
```

The plot for bivariate FMEs uses a color scale to indicate direction and magnitude of the estimated effect. Let's check the AME:

```{r}
effects3$ame
```

It seems that a combined decrease in temperature by 3°C and humidity by 10 percentage points seems to result in slightly lower bike sharing usage (on average). However, a quick check of the variance of FMEs tells us that effects are highly heterogeneous:

```{r}
var(effects3$results$fme)
```

Therefore, it could be interesting to move the interpretation of feature effects from a global to a semi-global perspective via the `came()` function.

------

## Semi-global Interpretations

You can use `came()` on a specific FME object to compute subspaces of the feature space where FMEs are more homogeneous. Let's take the effect of a decrease in temperature by 3°C combined with a decrease in humidity by 10 percentage points, and see if we can find three appropriate subspaces.

```{r}
subspaces = came(effects = effects3, number.partitions = 3)
summary(subspaces)
```

As can be seen, the CTREE algorithm was used to partition the feature space into three subspaces. The coefficient of variation (CoV) is used as a criterion to measure homogeneity in each subspace. We can see that the CoV is substantially smaller in each of the subspaces than in the root node, i.e. the global feature space. The conditional AME (cAME) can be used to interpret how the expected FME varies across the subspaces. Let's visualize our results:

```{r}
plot(subspaces)
```

In this case, we get a decision tree that assigns observations to a feature subspace according to the weather situation (`weather`) and season (`season`). The information contained in the boxes below the terminal nodes are equivalent to the summary output and can be extracted from `subspaces$results`. With cAMEs of 6.68, -9.39, and 16.71, respectively, the expected ME is estimated to vary substantially in direction and magnitude across the subspaces. For example, the cAME is highest on rainy days. It turns negative on non-rainy days in spring, summer and winter.

---

## References

Fanaee-T, H. and Gama, J. (2014). Event labeling combining ensemble detectors and background knowledge,
Progress in Artificial Intelligence 2(2): 113–127.

Vanschoren, J., van Rijn, J. N., Bischl, B. and Torgo, L. (2013). Openml: networked science in machine
learning, SIGKDD Explorations 15(2): 49–60. URL: http://doi.acm.org/10.1145/2641190.264119

[1]: https://arxiv.org/abs/2201.08837

[2]: https://www.openml.org/search?type=data&status=active&id=42712

[3]: https://mlr3learners.mlr-org.com/
